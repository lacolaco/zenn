---
title: "ビュー"
free: true
---

## ビューはひとかたまりに処理される表示要素のグループである

Angularにおける **[ビュー][]**（view）は、UI描画の過程において**ひとまとまりに生成・更新・破棄される表示要素の最小グループ**であると定義される。ビューはその生成の仕方から三種類に分けられる。

第一のビューは**ルートビュー**（root view）である。これはAngularアプリケーションの実行単位ごとに一つだけ存在し、他のすべてのビューを内包するビューである。
ルートビューはAngularアプリケーションの起動時に生成され、アプリケーションの終了時に破棄されるが、開発者がルートビューの存在を意識することはまれである。

第二のビューは**コンポーネントビュー**（component view）である。その名の通り、これはAngularコンポーネントに紐付いたビューである。コンポーネントのインスタンスは、そのコンポーネントのテンプレートが定義するビューに紐付けられる。

第三のビューは**埋め込みビュー**（embedded view）である。埋め込みビューはコンポーネントのテンプレートの一部として定義される。埋め込みビューを作るのは、構造ディレクティブ（structual directive）または`<ng-template>`タグによって宣言されるテンプレートである。このビューは、コンポーネントやディレクティブの処理によって別のビューの内部に埋め込まれることで描画される。

## ビューは階層構造を作る

Angularアプリケーションを起動（bootstrap）するためには、ルートモジュールの `bootstrap` フィールドで宣言されるルートコンポーネント（root component）が必要である。ルートコンポーネントはアプリケーションを構成する**コンポーネントツリー**（component tree）の頂点になる特別なコンポーネントだが、それと同時に、他のコンポーネントと同じようにテンプレートによって定義されるコンポーネントビューを持つ。

前述のとおり、あらゆるビューはルートビューに内包される。ルートコンポーネントのコンポーネントビューは、ルートビューが内包する最初のビューとなる。こうしてビューにもっとも小さい階層構造が生まれる。さらに、ルートコンポーネントのテンプレートで他のコンポーネントを呼び出すと、コンポーネントビュー同士の親子関係により階層構造が拡大する。

このようにビューはルートビューを頂点とした階層構造を作るが、はじめに定義したとおりビューとはひとまとまりに生成・更新・破棄される表示要素の最小グループである。生成・更新・破棄を**ライフサイクル**と言い換えれば、同じライフサイクルで管理される表示要素の最小グループと呼ぶこともできる。どちらにせよビューは表示要素のグループであるが、下位のビューは上位のビューにとって表示要素のひとつであるという点が重要である。

## 下位のビューを処理せず上位のビューだけを処理することはできない

これはコンポーネントツリーから考えればわかりやすい。末端のコンポーネントビューはそのコンポーネントテンプレートに直接記述された表示要素だけを管理しており、そのコンポーネントビューは単体でライフサイクルが完結している。だがひとつ上の階層にあるコンポーネントビューは単体では完結しておらず、下位のビューのライフサイクルを内包しなければならない。このことは実際にAngularのライフサイクルメソッドの呼び出し順から確認することもできる。2つのコンポーネントが親子関係にあるとき、`ngOnInit()`と`ngAfterViewInit()`は次のような順番で呼び出される。

1. 親 `ngOnInit()`
1. 子 `ngOnInit()`
1. 子 `ngAfterViewInit()`
1. 親 `ngAfterViewInit()`

![](https://storage.googleapis.com/zenn-user-upload/57f91f32bb5d-20211218.png)

あるビューの描画処理は、それを内包する上位のビューの描画処理の一部として開始される。そして、上位のビューの描画処理の完了はすべての下位のビューの描画処理の完了を待つことになる。このことから、**下位のビューを処理せず上位のビューだけを処理することはできない**という原則が導かれる。また、ルートビューが最上位のビューであるということは、すなわちアプリケーションの描画処理がルートビューの描画処理と同義だということである。したがって、アプリケーションの描画処理はルートビューから開始し、ルートビューの描画完了をもって終わる。


## 変更検知はビューの階層構造にしたがって実行される

**[変更検知][]**(change detection)は、AngularフレームワークがアプリケーションのUIの状態をデータの状態と同期させるメカニズムであると定義される。つまり、ビューが管理する状態とコンポーネントインスタンスの状態を比較し、差異があればコンポーネントインスタンスの状態を基にビューを再描画することを指す。

変更検知がビューの描画処理であるということは、変更検知もまたルートビューから階層構造にしたがって連鎖的に実行されることを意味する。つまり、上位のビューで変更検知が行われた結果が下位のビューの描画へ影響するが、逆に下位のビューの変更検知が上位のビューへ影響することはない。ただし、コンポーネントの実装の誤りによりそのような振る舞いが発生することはありえるため、変更検知により何らかの副作用が発生したときには、Angularは[`ExpressionChangedAfterItHasBeenCheckedError`](https://angular.jp/errors/NG0100)をスローして開発者に警告する。

また、[ChangeDetectorRef][]は、開発者が変更検知を明示的に実行するために使用できるAPIである。ひとつの`ChangeDetectorRef`インスタンスは特定のビューの変更検知を制御する。つまりビューのインスタンスと`ChangeDetectorRef`のインスタンスは1:1に対応している。このクラスが提供する`detectChanges()`メソッドは、対象のビューだけでなく子孫となる下位のビューでも変更検知を実行する。これも上位のビューだけを処理することができないためである。

## `OnPush`ストラテジーは変更検知の実行に条件を加える

ところで、「下位のビューを処理せず上位のビューだけを処理することはできない」という原則には例外がある。それはコンポーネントの[変更検知ストラテジー](https://angular.jp/api/core/ChangeDetectionStrategy)が `OnPush`に設定されている場合である。デフォルトの変更検知ストラテジーでは、上位のビューで変更検知が実行されるとその下位のビューも連鎖的に変更検知が実行される。つまり、ルートビューから変更検知が開始すればすべてのビューが変更検知されるということになる。これは整合性を守るための振る舞いだが、アプリケーションが大きくなると実行時パフォーマンスの低下を招く。
`OnPush`ストラテジーは特定のビューの変更検知を実行される条件を限定し、整合性の確保を開発者に移譲する代わりにパフォーマンスを最適化可能にする。その条件の詳細はここでは割愛するが、下位のビューが`OnPush`ストラテジーであればその変更検知をスキップして上位のビューの変更検知を終えることができる。


[ビュー]: https://angular.jp/guide/glossary#%E3%83%93%E3%83%A5%E3%83%BC
[変更検知]: https://angular.jp/guide/glossary#%E5%A4%89%E6%9B%B4%E6%A4%9C%E7%9F%A5
[ChangeDetectorRef]: https://angular.jp/api/core/ChangeDetectorRef